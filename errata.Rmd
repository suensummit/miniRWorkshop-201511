---
title: "勘誤 Errata"
author: "Summit Suen"
date: "December 1, 2015"
output: html_document
---
---

## [超展開數學教室：賴以威](http://opinion.udn.com/opinion/story/8159/1317267)

當我們想利用迴圈來計算在文章中提到的[等比級數](https://zh.wikipedia.org/wiki/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97)時，必須小心的是，迴圈內變數的數值是不是會被更新；像是原本上課提供的程式碼中，就出現了明顯的錯誤示範：

```{r}
p <- 1/2
for (i in 1:100000){
  p <- p + p*(1/4)^i
}
p
```

可以看到算出來的數字距離真實數字（$$\frac{2}{3} = 0.6666667$$）的差距不符合我們的預期。這跟使用迴圈或是向量造成的效率差異無關，而是因為在迴圈迭代的過程中，p 的數值其實是一直在變化的：$$p_i = p_{i-1} + p_{i-1}(\frac{1}{4})^i$$，而後面一直加上的這一項所代表的，其實是每次重新擲筊時，都有 1/2 的機率會擲出聖筊；因此，第二項中的 $$p_{i-1}$$ 應該要改為定值的 1/2，修改過後變成像下面的迴圈：

```{r}
p <- 0
for (t in 0:100000){
  p <- p + 1/2*(1/4)^t
}
p
```

我們可以看到，這次算出來的數值就是精確的。

## R 語言的強項：向量運算

那麼，在 R 裡面用迴圈好像也不是什麼壞事？其實，我們可以利用 `proc.time` 這個內建函式，來檢驗程式碼的效率。

首先來看迴圈版本：

```{r}
temp <- proc.time()	## current time record
p <- 0
for (t in 0:100000){
  p <- p + 1/2*(1/4)^t
}
(spttime <- proc.time() - temp)
p
```

接著，是利用向量方式計算的

```{r}
# temp <- proc.time()	## current time record
# p <- 1/2
# t <- c(0:1000)
# p <- p*sum((1/4)^t)
temp <- proc.time()	## current time record
p <- 1/2*sum((1/4)^c(0:100000)) # calculate in one line
(spttime <- proc.time() - temp)
p
```

我們可以明顯看到，兩種方式算出來的數值都是一樣的；但是在執行效率方面，隨著執行次數的累加，運算時間的差距也開始顯著的拉大。

因此，經過這個小小的實驗，我們可以發現，在 R 裡面如果可以使用向量的運算去處理一般要用迴圈迭代的工作，是可以顯著地提升程式碼的執行效率的。

## [回到講義](index.html)